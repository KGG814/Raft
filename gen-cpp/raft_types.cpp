/**
 * Autogenerated by Thrift Compiler (1.0.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "raft_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>




RequestVote::~RequestVote() throw() {
}


void RequestVote::__set_term(const int32_t val) {
  this->term = val;
}

void RequestVote::__set_candidateID(const int32_t val) {
  this->candidateID = val;
}

void RequestVote::__set_lastLogIndex(const int32_t val) {
  this->lastLogIndex = val;
}

void RequestVote::__set_lastLogTerm(const int32_t val) {
  this->lastLogTerm = val;
}

const char* RequestVote::ascii_fingerprint = "154BB42C2FFD70F8B3993568C50C5613";
const uint8_t RequestVote::binary_fingerprint[16] = {0x15,0x4B,0xB4,0x2C,0x2F,0xFD,0x70,0xF8,0xB3,0x99,0x35,0x68,0xC5,0x0C,0x56,0x13};

uint32_t RequestVote::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->term);
          this->__isset.term = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->candidateID);
          this->__isset.candidateID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->lastLogIndex);
          this->__isset.lastLogIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->lastLogTerm);
          this->__isset.lastLogTerm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RequestVote::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("RequestVote");

  xfer += oprot->writeFieldBegin("term", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->term);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("candidateID", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->candidateID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lastLogIndex", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->lastLogIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lastLogTerm", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->lastLogTerm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(RequestVote &a, RequestVote &b) {
  using ::std::swap;
  swap(a.term, b.term);
  swap(a.candidateID, b.candidateID);
  swap(a.lastLogIndex, b.lastLogIndex);
  swap(a.lastLogTerm, b.lastLogTerm);
  swap(a.__isset, b.__isset);
}

RequestVote::RequestVote(const RequestVote& other0) {
  term = other0.term;
  candidateID = other0.candidateID;
  lastLogIndex = other0.lastLogIndex;
  lastLogTerm = other0.lastLogTerm;
  __isset = other0.__isset;
}
RequestVote& RequestVote::operator=(const RequestVote& other1) {
  term = other1.term;
  candidateID = other1.candidateID;
  lastLogIndex = other1.lastLogIndex;
  lastLogTerm = other1.lastLogTerm;
  __isset = other1.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const RequestVote& obj) {
  using apache::thrift::to_string;
  out << "RequestVote(";
  out << "term=" << to_string(obj.term);
  out << ", " << "candidateID=" << to_string(obj.candidateID);
  out << ", " << "lastLogIndex=" << to_string(obj.lastLogIndex);
  out << ", " << "lastLogTerm=" << to_string(obj.lastLogTerm);
  out << ")";
  return out;
}


VoteResponse::~VoteResponse() throw() {
}


void VoteResponse::__set_term(const int32_t val) {
  this->term = val;
}

void VoteResponse::__set_voteGranted(const bool val) {
  this->voteGranted = val;
}

const char* VoteResponse::ascii_fingerprint = "4DC0C1A1F380340B40244ADC7FB0BA60";
const uint8_t VoteResponse::binary_fingerprint[16] = {0x4D,0xC0,0xC1,0xA1,0xF3,0x80,0x34,0x0B,0x40,0x24,0x4A,0xDC,0x7F,0xB0,0xBA,0x60};

uint32_t VoteResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->term);
          this->__isset.term = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->voteGranted);
          this->__isset.voteGranted = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t VoteResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("VoteResponse");

  xfer += oprot->writeFieldBegin("term", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->term);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("voteGranted", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->voteGranted);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(VoteResponse &a, VoteResponse &b) {
  using ::std::swap;
  swap(a.term, b.term);
  swap(a.voteGranted, b.voteGranted);
  swap(a.__isset, b.__isset);
}

VoteResponse::VoteResponse(const VoteResponse& other2) {
  term = other2.term;
  voteGranted = other2.voteGranted;
  __isset = other2.__isset;
}
VoteResponse& VoteResponse::operator=(const VoteResponse& other3) {
  term = other3.term;
  voteGranted = other3.voteGranted;
  __isset = other3.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const VoteResponse& obj) {
  using apache::thrift::to_string;
  out << "VoteResponse(";
  out << "term=" << to_string(obj.term);
  out << ", " << "voteGranted=" << to_string(obj.voteGranted);
  out << ")";
  return out;
}


AppendEntries::~AppendEntries() throw() {
}


void AppendEntries::__set_term(const int32_t val) {
  this->term = val;
}

void AppendEntries::__set_leaderID(const int32_t val) {
  this->leaderID = val;
}

void AppendEntries::__set_prevLogIndex(const int32_t val) {
  this->prevLogIndex = val;
}

void AppendEntries::__set_prevLogTerm(const int32_t val) {
  this->prevLogTerm = val;
}

void AppendEntries::__set_entries(const std::vector<int32_t> & val) {
  this->entries = val;
}

void AppendEntries::__set_leaderCommit(const int32_t val) {
  this->leaderCommit = val;
}

const char* AppendEntries::ascii_fingerprint = "BC8E1F72C3EA586FC235843B2F052EA6";
const uint8_t AppendEntries::binary_fingerprint[16] = {0xBC,0x8E,0x1F,0x72,0xC3,0xEA,0x58,0x6F,0xC2,0x35,0x84,0x3B,0x2F,0x05,0x2E,0xA6};

uint32_t AppendEntries::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->term);
          this->__isset.term = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->leaderID);
          this->__isset.leaderID = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->prevLogIndex);
          this->__isset.prevLogIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->prevLogTerm);
          this->__isset.prevLogTerm = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->entries.clear();
            uint32_t _size4;
            ::apache::thrift::protocol::TType _etype7;
            xfer += iprot->readListBegin(_etype7, _size4);
            this->entries.resize(_size4);
            uint32_t _i8;
            for (_i8 = 0; _i8 < _size4; ++_i8)
            {
              xfer += iprot->readI32(this->entries[_i8]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.entries = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->leaderCommit);
          this->__isset.leaderCommit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AppendEntries::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("AppendEntries");

  xfer += oprot->writeFieldBegin("term", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->term);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("leaderID", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->leaderID);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("prevLogIndex", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->prevLogIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("prevLogTerm", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->prevLogTerm);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("entries", ::apache::thrift::protocol::T_LIST, 5);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->entries.size()));
    std::vector<int32_t> ::const_iterator _iter9;
    for (_iter9 = this->entries.begin(); _iter9 != this->entries.end(); ++_iter9)
    {
      xfer += oprot->writeI32((*_iter9));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("leaderCommit", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->leaderCommit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(AppendEntries &a, AppendEntries &b) {
  using ::std::swap;
  swap(a.term, b.term);
  swap(a.leaderID, b.leaderID);
  swap(a.prevLogIndex, b.prevLogIndex);
  swap(a.prevLogTerm, b.prevLogTerm);
  swap(a.entries, b.entries);
  swap(a.leaderCommit, b.leaderCommit);
  swap(a.__isset, b.__isset);
}

AppendEntries::AppendEntries(const AppendEntries& other10) {
  term = other10.term;
  leaderID = other10.leaderID;
  prevLogIndex = other10.prevLogIndex;
  prevLogTerm = other10.prevLogTerm;
  entries = other10.entries;
  leaderCommit = other10.leaderCommit;
  __isset = other10.__isset;
}
AppendEntries& AppendEntries::operator=(const AppendEntries& other11) {
  term = other11.term;
  leaderID = other11.leaderID;
  prevLogIndex = other11.prevLogIndex;
  prevLogTerm = other11.prevLogTerm;
  entries = other11.entries;
  leaderCommit = other11.leaderCommit;
  __isset = other11.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const AppendEntries& obj) {
  using apache::thrift::to_string;
  out << "AppendEntries(";
  out << "term=" << to_string(obj.term);
  out << ", " << "leaderID=" << to_string(obj.leaderID);
  out << ", " << "prevLogIndex=" << to_string(obj.prevLogIndex);
  out << ", " << "prevLogTerm=" << to_string(obj.prevLogTerm);
  out << ", " << "entries=" << to_string(obj.entries);
  out << ", " << "leaderCommit=" << to_string(obj.leaderCommit);
  out << ")";
  return out;
}


AppendResponse::~AppendResponse() throw() {
}


void AppendResponse::__set_term(const int32_t val) {
  this->term = val;
}

void AppendResponse::__set_success(const bool val) {
  this->success = val;
}

const char* AppendResponse::ascii_fingerprint = "4DC0C1A1F380340B40244ADC7FB0BA60";
const uint8_t AppendResponse::binary_fingerprint[16] = {0x4D,0xC0,0xC1,0xA1,0xF3,0x80,0x34,0x0B,0x40,0x24,0x4A,0xDC,0x7F,0xB0,0xBA,0x60};

uint32_t AppendResponse::read(::apache::thrift::protocol::TProtocol* iprot) {

  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->term);
          this->__isset.term = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->success);
          this->__isset.success = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AppendResponse::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  oprot->incrementRecursionDepth();
  xfer += oprot->writeStructBegin("AppendResponse");

  xfer += oprot->writeFieldBegin("term", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->term);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("success", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->success);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  oprot->decrementRecursionDepth();
  return xfer;
}

void swap(AppendResponse &a, AppendResponse &b) {
  using ::std::swap;
  swap(a.term, b.term);
  swap(a.success, b.success);
  swap(a.__isset, b.__isset);
}

AppendResponse::AppendResponse(const AppendResponse& other12) {
  term = other12.term;
  success = other12.success;
  __isset = other12.__isset;
}
AppendResponse& AppendResponse::operator=(const AppendResponse& other13) {
  term = other13.term;
  success = other13.success;
  __isset = other13.__isset;
  return *this;
}
std::ostream& operator<<(std::ostream& out, const AppendResponse& obj) {
  using apache::thrift::to_string;
  out << "AppendResponse(";
  out << "term=" << to_string(obj.term);
  out << ", " << "success=" << to_string(obj.success);
  out << ")";
  return out;
}


