// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include <iostream>
#include <fstream>
#include <boost/thread/thread.hpp>

#include "Raft.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TSocket.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

#include <thread>
#include <chrono>
#include <ctime>

#include <boost/thread.hpp>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
using boost::shared_ptr;

#define TIMEOUT 15

#define NONE 0

#define MAJ 3
#define NUM_SERVERS 5

#define ID 1
#define SERVERS 2
#define MIN_ARGS 3

#define FOLLOWER 0
#define CANDIDATE 1
#define LEADER 2

VoteResponse requestVote (int sendPort);
void timer (void);

std::chrono::system_clock::time_point msgTime;
boost::condition_variable cond;
boost::mutex voteLock;
boost::thread msgTimer;
int port = 0;
std::map<int, int> serverID;

// Raft server state

int id;                             // Unique ID for node
int state;                          // What state node is in
int numVotes;                       // Votes node has in current term

// Persistent     
int currentTerm;                    // Term node is in
int votedFor;                       // Who it voted for in current term
std::vector<LogEntry> raftLog;

// Volatile
int commitIndex;
int lastApplied;

// Leader only
int nextIndex [5];
int matchIndex [5];


class RaftHandler : virtual public RaftIf {
 public:

  RaftHandler() {
    // State initialization
    currentTerm = 0;
    state = FOLLOWER;
    votedFor = NONE;
    commitIndex = 0;
    lastApplied = 0;
    numVotes = 0;
    msgTime = std::chrono::system_clock::now();
    std::cout << "server started" << std::endl;
  }

  bool RequestVoteRPC(const RequestVote& vote) {
    std::cout << "RequestVoteRPC" << std::endl;
    if (state == LEADER) {
      // Leader handling, probably ignore
    } else if (state == FOLLOWER) {
      // Check terms and send vote
    } else if (state == CANDIDATE) {
      // Do nothing
    }
  }

  bool AppendEntriesRPC(const AppendEntries& append) {
    printf("AppendEntriesRPC\n");

    /* TODO Handling for new server
    if 
    
    */
    if (state == LEADER) {
      // Leader handling
    } else if (state == FOLLOWER) {
      // Check terms and send vote
    } else if (state == CANDIDATE) {
      // If term received is >= currentTerm, return to follower state
      state = FOLLOWER;
      msgTimer.interrupt();
      // If not, continue in candidate
    }
  }

};

int main(int argc, char **argv) {
  

  if (argc >= MIN_ARGS) {
    // Server Information
    id = atoi(argv[ID]);
  } else {
    std::cout << "Usage: ./server [ID] [serverfile]" << std::endl;
    return 1;
  }
  
  //TODO Get server ports and put in map
  std::string serverPort;
  std::ifstream servers (argv[SERVERS]);
  int i = 1;

  if (servers.is_open()) {
    while (std::getline(servers, serverPort)) {    
      serverID[i] = stoi(serverPort);
      if (id == i) {
         port = serverID[i];
      }
      i++;
    }
  }
  
  std::cout << port << std::endl;

  // Raft stuff
  shared_ptr<RaftHandler> handler(new RaftHandler());
  shared_ptr<TProcessor> processor(new RaftProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  // Initialise and start the timer and server
  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  boost::thread msgTimer (timer);
  server.serve();
  
  return 0;
}

void timer (void) {
  std::string server;
  
  while (1) {

    if (std::chrono::system_clock::now() >= msgTime + std::chrono::seconds(TIMEOUT)
        && state == FOLLOWER) {    
      // Candidate handling
      std::cout << "Candidate mode" << std::endl;
      state = CANDIDATE;
      currentTerm++;
      // Vote for self
      votedFor = id;
      numVotes++;

      // Issue request vote RPCs (new threads)
      for (int i = 1; i <= NUM_SERVERS; i++) {
    	  if (id != i) {
          //TODO Make thread array
          boost::thread voteThread (requestVote, serverID[i]);
        }
      }
      // Wait for response
      boost::unique_lock<boost::mutex> lock(voteLock);
      try {
        while (numVotes < MAJ) {
          cond.wait(lock);
        }
      } catch (boost::thread_interrupted&) {
        // If valid AppendEntries received, thread will be reset
        std::cout << "Resetting timer" << std::endl;
        msgTime = std::chrono::system_clock::now();
        continue;        
      } 
 
      // If successful, leader 
      std::cout << "Leader" << std::endl;
      state = LEADER;    
    }
  }
}

VoteResponse requestVote (int sendPort) {
  //TODO Store response in array
  // Create the socket, transport and protocol structures for thrift.
  std::cout << "Requesting votes: " << sendPort << std::endl;
  boost::shared_ptr<TTransport> socket(new TSocket("127.0.0.1", sendPort));
  boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
  boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));

  VoteResponse response;
  RequestVote vote;

  // The thrift client
  RaftClient client(protocol);

  try {
    
    transport->open();
    std::cout << "Request sent: " << sendPort << std::endl;
    // TODO Fill in request
    client.RequestVoteRPC(vote);
    // TODO Check if succesful vote before incrementing
    std::cout << "Vote received: " << sendPort << std::endl;
    voteLock.lock();
    numVotes++;
    voteLock.unlock();
    cond.notify_one();
    transport->close();

  } catch (TException &tx) {
    std::cout << "Connection Failed" << std::endl;
  } catch (boost::thread_interrupted&) {
    return response;
  }
}
