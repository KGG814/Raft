// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include <iostream>
#include <fstream>
#include <boost/thread/thread.hpp>

#include "Raft.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TSocket.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

#include <thread>
#include <chrono>
#include <ctime>

#include <boost/thread.hpp>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
using boost::shared_ptr;

#define TIMEOUT 1000
#define RESEND 800

// Iniital value in the log
#define INITIAL 0xDEADBEEF

// No one voted for
#define NONE 0

// Number of servers and majority
// Number of servers should be odd
// Majority should be ceil(NUM_SERVERS/2)
#define MAJ 2
#define NUM_SERVERS 3

// Arguments
#define ID 1
#define SERVERS 2
#define MIN_ARGS 3

// States
#define FOLLOWER 0
#define CANDIDATE 1
#define LEADER 2

// Set to true for debug output
int debug = true;

// Wrapper functions for RPCs
void requestVote (int voteID);
void sendHeartbeat (int voteID);

//Timer to determine when a follower should timeout and transition to candidate
void heartbeatTimer (void);



std::chrono::system_clock::time_point msgTime; // TODO lock
boost::condition_variable cond;
boost::mutex voteLock;
boost::mutex responseLock;

// Need to use a list because we cannot guarantee that a timer will finish before it is restarted.
// However this should contain 1 element 99% of the time, and not more than 2.
std::list<boost::thread *> timeOuts; 
int port = 0;
std::map<int, int> serverID;

// Raft server state

int id;                             // Unique ID for node
int state;                          // What state node is in TODO lock
int numVotes;                       // Votes node has in current term
int numResponse;

// Persistent     
int currentTerm;                    // Term node is in TODO lock
int votedFor;                       // Who it voted for in current term TODO lock
std::vector<LogEntry> raftLog;

// Volatile
int commitIndex;
int lastApplied;

// Leader only
int nextIndex [5];
int matchIndex [5];


class RaftHandler : virtual public RaftIf {
 public:

  RaftHandler() {
    LogEntry initial;
    initial.term = 0;
    initial.number = INITIAL;
    // State initialization
    currentTerm = 0;
    state = FOLLOWER;
    votedFor = NONE; 
    commitIndex = 0;
    lastApplied = 0;
    numVotes = 0;
    numResponse = 0;
    msgTime = std::chrono::system_clock::now();
    raftLog.push_back(initial);
    std::cout << "server started" << std::endl;
  }

  void RequestVoteRPC(VoteResponse& _return, const RequestVote& vote) {
    if (debug) {std::cout << "RequestVoteRPC" << std::endl;}
    if (state == LEADER) {
      if (vote.term > currentTerm) {
        // TODO might be some problems here when log checking is implemented
        currentTerm = vote.term;
        state = FOLLOWER;
        votedFor = vote.candidateID;
        // Restart timeout timer
        msgTime = std::chrono::system_clock::now();
        // Return
        _return.voteGranted = true;
        _return.term = currentTerm;
      } else {
        // Return
        _return.voteGranted = false;
        _return.term = currentTerm;
      }
    } else if (state == FOLLOWER) {
      if (vote.term < currentTerm) {  
        // Return
        _return.voteGranted = false;
        _return.term = currentTerm;
      } else if (vote.term > currentTerm) {
        currentTerm = vote.term;
        if (vote.lastLogIndex >= raftLog.size()-1) {
          votedFor = vote.candidateID;      
          msgTime = std::chrono::system_clock::now();
          // Return
          _return.voteGranted = true;
          _return.term = currentTerm;
        } else {
          votedFor = NONE;
          // Return
          _return.voteGranted = false;
        } 
      } else {
        if (votedFor == NONE || votedFor == vote.candidateID) {
          if (vote.lastLogIndex >= raftLog.size()-1) {
            votedFor = vote.candidateID;
            msgTime = std::chrono::system_clock::now();
            // Return
            _return.voteGranted = true;
            _return.term = currentTerm;
          } else {
            _return.voteGranted = false;
            _return.term = currentTerm;
          }
        } else {
          _return.voteGranted = false;
          _return.term = currentTerm;
        }
      }
    } else if (state == CANDIDATE) {
      if (vote.term > currentTerm) {
        timeOuts.front()->interrupt();
        state = FOLLOWER; 
        currentTerm = vote.term;     
        _return.voteGranted = true;
        _return.term = currentTerm;
        if (debug)
        {std::cout << "Candidate -> Follower:  " << currentTerm << std::endl;}
        std::cout << state << std::endl;
      }
      
    }
  }

  void AppendEntriesRPC(AppendResponse& _return, const AppendEntries& append) {
    if (debug) {std::cout << "AppendEntriesRPC" << std::endl;}
    if (state == LEADER) {
      // Something weird happens
      msgTime = std::chrono::system_clock::now();
    } else if (state == FOLLOWER) {
      //TODO Handle checking terms etc. properly
      msgTime = std::chrono::system_clock::now();
      currentTerm = append.term;
      std::cout << "Heartbeat received" << std::endl;
    } else if (state == CANDIDATE) {
      // If term received is >= currentTerm, return to follower state
      msgTime = std::chrono::system_clock::now();
      if (append.term >= currentTerm) {
        state = FOLLOWER;
        if (raftLog[append.prevLogIndex].term == append.prevLogTerm) {
          _return.success = true;
        }
        //TODO Delete conflicting entries of new entries
        //TODO Append entries
        //TODO If leaderCommit > commitIndex, 
        //commitIndex = min(leaderCommit, last new entry)
        //std::cout << "Candidate -> Follower: " << currentTerm << std::endl;
        currentTerm = append.term;
        // TODO Make this interupt properly??
        timeOuts.front()->interrupt();
        state = FOLLOWER; 
        if (debug)
        {std::cout << "Candidate -> Follower:  " << currentTerm << std::endl;}
      }
      // If not, continue in candidate
    }
  }

};

int main(int argc, char **argv) {
  

  if (argc >= MIN_ARGS) {
    // Server Information
    id = atoi(argv[ID]);
  } else {
    std::cout << "Usage: ./server [ID] [serverfile]" << std::endl;
    return 1;
  }
  
  std::string serverPort;
  std::ifstream servers (argv[SERVERS]);
  int i = 1;

  if (servers.is_open()) {
    while (std::getline(servers, serverPort)) {    
      serverID[i] = stoi(serverPort);
      if (id == i) {
         port = serverID[i];
      }
      i++;
    }
  }
  if (port == 0) {
    std::cout << "ID not found" <<std::endl;
    return 1;
  }
  std::cout << port << std::endl;

  // Raft stuff
  shared_ptr<RaftHandler> handler(new RaftHandler());
  shared_ptr<TProcessor> processor(new RaftProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  // Initialise and start the timer and server
  TSimpleServer server(processor, serverTransport, transportFactory,
  protocolFactory);
  timeOuts.push_back(new boost::thread(heartbeatTimer));
  
  server.serve();
  
  return 0;
}

void heartbeatTimer (void) {
  std::string server; 
  srand (time(NULL));
  int rnd = rand() % 200;
  std::cout << rnd << std::endl;
  while (1) {
    try {
      // Maintain Leader status
      if (std::chrono::system_clock::now() >= msgTime + std::chrono::milliseconds
      (RESEND) && state == LEADER) {
        // Send blank AppendEntries to assert dominance
        std::cout << "Maintaining leader status" << std::endl;
        for (int i = 1; i <= NUM_SERVERS; i++) {
    	    if (id != i) {
            boost::thread heartbeatThread (sendHeartbeat, i);
          }
        }
        msgTime = std::chrono::system_clock::now();
      }
    
      // Election timeout
      if (std::chrono::system_clock::now() >= msgTime + 
          std::chrono::milliseconds(TIMEOUT) +
          std::chrono::milliseconds(rnd)
          && state == FOLLOWER) {    
        // Candidate handling
        boost::unique_lock<boost::mutex> lock(responseLock);
        if (debug) {std::cout << "Follower -> Candidate: " << currentTerm+1
        << std::endl;}
        voteStart:
        state = CANDIDATE;      
        srand (time(NULL)*(id+1));
        rnd = rand() % 200;
        currentTerm++;
        // Vote for self
        votedFor = id;
        numVotes = 1;
        numResponse = 1;
        
        // Issue request vote RPCs (new threads)
        msgTime = std::chrono::system_clock::now();
        for (int i = 1; i <= NUM_SERVERS; i++) {
      	  if (id != i) {
            boost::thread voteThread (requestVote, i);
          }
        }
        // Wait for response
        while (numVotes < MAJ) {
          if (numResponse == NUM_SERVERS) {
            while (std::chrono::system_clock::now() < msgTime +
                   std::chrono::milliseconds(TIMEOUT) +
                   std::chrono::milliseconds(rnd)) {};
            msgTime = std::chrono::system_clock::now();
            std::cout << rnd << std::endl;
            std::cout << "Resetting election" << std::endl;
            goto voteStart;
          }
          cond.wait(lock);
        }
        

        // If successful, leader
        std::cout << "Candidate -> Leader:    " << currentTerm << std::endl;
        state = LEADER; 
        msgTime = std::chrono::system_clock::now();
        // Send blank AppendEntries to assert dominance
        for (int i = 1; i <= NUM_SERVERS; i++) {
      	  if (id != i) {
            boost::thread heartbeatThread (sendHeartbeat, i);
          }
        }
      }
    } catch (boost::thread_interrupted&) {
      // If valid AppendEntries received, thread will be reset
      msgTime = std::chrono::system_clock::now();
      break;
    } catch (TException &tx) {
    }
  }
}

void requestVote (int voteID) {
  //TODO Add timeouts and reset, might be able to use thrift API
  // Create the socket, transport and protocol structures for thrift.
  if (debug) {std::cout << "Requesting votes: " << voteID << std::endl;}
  TSocket* _socket = new TSocket("127.0.0.1", serverID[voteID]);
	_socket->setRecvTimeout(1000);
	_socket->setConnTimeout(1000);
  boost::shared_ptr<TTransport> socket(_socket);
  boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
  boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));

  VoteResponse response;
  RequestVote request;

  // The thrift client
  RaftClient client(protocol);

  try {
    transport->open();
    // Fill in request
    request.term = currentTerm;
    request.candidateID = id;
    request.lastLogIndex = raftLog.size()-1;
    request.lastLogTerm = raftLog[request.lastLogIndex].term;
    client.RequestVoteRPC(response, request);

    if (response.voteGranted == true) {
      if (debug) {std::cout << "Vote received: " << voteID << std::endl;}
      voteLock.lock();
      numVotes++;     
      voteLock.unlock();
      responseLock.lock();
      numResponse++;
      responseLock.unlock();
      cond.notify_one();
    } else {
      if (debug) {std::cout << "Vote rejected: " << voteID << std::endl;}
      if (response.term > currentTerm) {
        currentTerm = response.term;
        votedFor = NONE;
      }
      responseLock.lock();
      numResponse++;
      responseLock.unlock();
      cond.notify_one();
    }
    transport->close();
  } catch (TException &tx) {
    if(debug) {std::cout << "Connection Failed: " << voteID << std::endl;}
    responseLock.lock();
    numResponse++;
    responseLock.unlock();
    cond.notify_one();
  } catch (boost::thread_interrupted&) {
  }
}

void sendHeartbeat (int voteID) {
     
  // Setup Raft connection
  //std::cout << "Sending heartbeat: " << voteID << std::endl;
  boost::shared_ptr<TTransport> socket(
  new TSocket("127.0.0.1", serverID[voteID]));
  boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
  boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
  RaftClient client(protocol);

  try {

    transport->open();    
    
    AppendResponse response;
    AppendEntries append;
    append.term = currentTerm;
    append.leaderID = id;
    append.prevLogIndex = raftLog.size()-1;
    append.prevLogTerm = raftLog[append.prevLogIndex].term;    
    append.leaderCommit = commitIndex;
    client.AppendEntriesRPC(response, append);
    transport->close();
  } catch (TException &tx) {
    //std::cout << "Connection Failed" << std::endl;
  }
}
